package jvm;

/**
 * @Author maqiuyue
 * @Date 2020/6/30 16:16
 * @description
 *
 * idea 调 -Xms ,-Xmx
 * 生产环境中 -Xms 与 -Xmx 一致，避免内存忽高忽低，产生停顿,(避免GC和应用程序争抢内存)
 *
 * 在启动类配置对话框中的VM options中配置 例（-Xms1024m -Xmx=1024 -XX:+PrintGCDetails）
 *
 * YGC 在新生代回收(使用复制算法)
 * 复制  eden+from 复制到to ，GC之后交换，from 与to，谁空谁是true，to变为from ,from变为to
 * 复制算法不会产生内存碎片。缺点占用空间大
 *
 * FGC新生代和养老代、元空间一起收
 *
 *   -XX:MaxTenuringThreshold   设置对象在新生代中存活的次数
 *
 * 1.  复制算法的缺点是相当明显的。 (新生代用得法算法)
 *     1.它浪费了一半的内存，这太要命了。
 *     2.如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用
 *     地址重置一遍，复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。所以从以上描述不难看出，
 *     复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。
 *
 * 2.标记清除算法：
 * 算法分成标记和清除两个阶段，先标记出要回收的对象，然后统一回收这些对象。
 * 当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，
 * 最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。
 * 缺点：会产生内存碎片
 *
 * 3.标记压缩算法：
 *   缺点：效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址.
 *   从效率上来讲，标记/整理算法要低于复制算法
 *   老年代一般是由标记清除或者是标记整理的混合实现
 *   优点：没有内存碎片
 *
 *  4. 引用计数算法
 *
 *
 *   GC算法（分代垃圾收集算法）
 *   总结：
 *   内存效率： 复制算法>标记清除算法>标记整理算法（此外的效率只是简单的对比时间复杂度，实际情况不一定如此）
 *   内存整齐度：复制算法=标记整理算法>标记清除算法
 *   内存利用率： 标记整理算法=标记清除算法>复制算法
 *
 *   可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，
 *   标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除了多一个整理内存的过程
 *
 *
 * 年轻代特点是区域相对老年代较小，对象存活率低。
 * 这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因而很适用于年轻代的回收。
 * 而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。
 *
 * 老年代的特点是区域较大，对象存活率高
 * 这种情况，存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记清除或者是标记整理的混合实现。
 *
 *
 */
public class T2 {
    public static void main(String[] args) {
        System.out.println(Runtime.getRuntime().availableProcessors()); //获取CPU核数
        long maxMemory = Runtime.getRuntime().maxMemory();//返回Java虚拟机试图使用的最大内存量
        long totalMemory = Runtime.getRuntime().totalMemory();//返回Java 虚拟机中的内存总量
        System.out.println("-Xmx:MAX_MEMORY="+maxMemory+"(字节)、"+(maxMemory/(double)1024/1024)+"MB");
        System.out.println("-Xms:TOTAL_MEMORY="+totalMemory+"(字节)、"+(totalMemory/(double)1024/1024)+"MB");
    }
}
